# CS-300
What was the problem you were solving in the projects for this course?

These projects attempted to solve a data management issue for a school advisor. The advisor need an application they could interact with to load a CSV file containing a program's course list, sort and print that list alphanumerically, and search and display individual courses.

How did you approach the problem? Consider why data structures are important to understand.

I think this problem was best approached from the viewpoint of the end user. There was no data structure considered that would not have worked, but there were certainly options more suitable than others. If it took a little more time to load a file, that would be okay because the user only needs to work with one file at a time. Sorting and searching however, are a higher priority and need to happen a little quicker.

How did you overcome any roadblocks you encountered while going through the activities or project?

Figuring out how to read and parse a CSV file to a vector proved a lot more difficult than I anticipated. It took a lot of trial and error to finally figure it out. I think the best strategy to completing that function was to study and use bits and pieces of code from reference material provided throughout the course as well as previous assignments. For me personally, there isn't a roadblock when it comes to pseudocode... pseudocode IS the roadblock. I only overcome it by finishing it and getting it out of the way. Maybe as my learning progresses I will find it more useful.

How has your work on this project expanded your approach to designing software and developing programs?

These projects really brought to light the different applications of various data structures and the consideration necessary to use not just what works, but what is most efficient. Moreover, I'm grateful for the cpp exposure.

How has your work on this project evolved the way you write programs that are maintainable, readable, and adaptable?

The way our assignments accumulated strategy and algorithms, culminating in these final projects, drove home how important it is to write modular and well-commented code. Every week there was something from the previous week worth going back and looking at or even borrowing from. For these final projects it was absolutely necessary we were able to do so. Had the code not been modular, or if I had to figure out what every block of code was doing, this process would have been painfully tedious.
